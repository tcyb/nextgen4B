import re, os, gzip, uuid
import logging
import numpy as np

from Bio import SeqIO, AlignIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Emboss.Applications import NeedleCommandline

__All__ = ['filter_sample']

#####################
# File Management
#####################

def loadNGSFileToIterator(fpath, ftype='fastq'):
    # Reads in files to an iterator using Bio.SeqIO.parse
    # Defaults to .fastq format
    # Will automatically unzip .gz files	
    
    if fpath.endswith('.gz'):
	   f = gzip.open(fpath, 'rb')
        
    elif fpath.endswith('.fastq'):
        f = open(fpath, 'rb')
    
    fIter = SeqIO.parse(f, ftype)    
    return fIter
    
def loadNGSFileToList(fpath, ftype='fastq'):
    # Reads in files to an iterator using Bio.SeqIO.parse
    # Defaults to .fastq format
    # Will automatically unzip .gz files	
    
    if fpath.endswith('.gz'):
	   f = gzip.open(fpath, 'rb')
        
    else:
        f = open(fpath, 'rb')
    
    fL = list(SeqIO.parse(f, ftype))    
    return fL
    
#####################
# Main Filter Code
#####################

def filter_sample(fName, peName, bcs, templates, f_filt_seqs, r_filt_seqs, saveIntermediate=False, saveEnd=False, preserveMemory=True):
    """
    Outputs filtered sequences as dictionary, indexed by barcode
    Sequences will be aligned to the provided template.
    Parts of the template not represented will be '-'
    """ 
    
    logging.info('Started filtering routine for %s' % (fName))
    
    # Do regex-based filtering
    fREs = compileREs(f_filt_seqs)
    peREs = compileREs(r_filt_seqs)
    
    # Load forward, PE reads
    if not preserveMemory:
        logging.info('Loading Files')
        fSeqs = list(loadNGSFileToIterator(fName))
        logging.info('Loaded %i forward read sequences'%len(fSeqs))
        for regex in fREs:
            fSeqs = filterSeqs(fSeqs, regex)
        peSeqs = list(loadNGSFileToIterator(peName))
        logging.info('Loaded %i paired-end sequences'%len(peSeqs))
        for regex in peREs:
            peSeqs = filterSeqs(peSeqs, regex)
    else:
        logging.info('Loading Files')
        fSeqs = loadNGSFileToIterator(fName)
        for regex in fREs:
            fSeqs = filterSeqs(fSeqs, regex)
        peSeqs = loadNGSFileToIterator(peName)
        for regex in peREs:
            peSeqs = filterSeqs(peSeqs, regex)
    
    # Barcode Filtering/Demux
    bcSeqs = barcodeDemux(fSeqs, bcs)
    
    # Sequence-based filtering
    for expt in bcs.keys():
        logging.info('Starting post-demux filtering for expt ID %s' % expt)
        # Filter based on PE matches, only return the copied sequence
        # Assumes the first RE in fREs will terminate the copied sequence
        # copiedFuncGenerator's output should return all sequence before the adapter
        seqs = filterPEMismatches(bcSeqs[expt], peSeqs, copiedFunctionGenerator(fREs))
        
        # Quality filter
        if len(seqs) > 0:
            seqs = qualityFilter(seqs) # Quality Filtering (needs to only have copied sequence)
        else:
            logging.info('No sequences left, skipped quality score filtering.\n*** Skipping remaining filtering for expt ID %s***' % expt)
            bcSeqs[expt] = seqs
            continue
        
        seqs = stripForwardBarcodes(seqs, l_barcode=len(bcs[expt])) # Remove barcodes before align
        
        # Align filter
        if len(seqs) > 0:
            seqs = alignfilter.alignmentFilter(seqs, templates[expt]) # Do alignment-based filtering
        else:
            logging.info('No sequences left, skipped align filtering.\n*** Skipping remaining filtering for expt ID %s***' % expt)
            bcSeqs[expt] = seqs
            continue
        
        # Length filtering
        if len(seqs) > 0:
            seqs = seqLenFilter(seqs, l_barcode=len(bcs[expt])) # Length Filtering
        else:
            logging.info('No sequences left, skipped length filtering.\n*** Skipping remaining filtering for expt ID %s***' % expt)
            bcSeqs[expt] = seqs
            continue
        
        bcSeqs[expt] = seqs
        
    return bcSeqs

#####################
# F/R Regex Filtering
#####################

def filterSeqs(sIO_L, q_re):
	# sIO_iterator should be generated by Bio.SeqIO.parse
	# q_re should be a regex object generated by re.compile()
	# Outputs a list of Seq objects that have the desired sequence in them.
    logging.info('Started regex filter: %s' % q_re.pattern)
    l = [s for s in sIO_L if q_re.search(str(s.seq))]    
    logging.info('Finished regex filter. Kept %i sequences.' % (len(l))) # in case we get an iterator

    return l
    
def compileREs(seqs):
    # Takes a list of sequences you want to filter for
    # Outputs a list of regex objects that you can iterate over
    reL = []
    for s in seqs:
        reL.append(re.compile(s))
    return reL

#####################
# Barcode Filtering
#####################

# Need to do this before alignment.
def stripForwardBarcodes(f_seqs, l_barcode=5):
    return [s[l_barcode:] for s in f_seqs]

def barcodeDemux(seqs, bcs):
    """Takes lists of sequence objects, dict of barcodes (indexed by expt. ID)
    Demuxes based on the barcode the sequences start with
    Discards sequences that don't start with a barcode exact match
    Assumes forward read -> sequences start with a barcode"""
    
    logging.info('Started barcode demuxing.')
    
    nSeqs = 0
    bc_filtered_data = {}
    for expt in bcs.keys():
        bc_filtered_data[expt] = [s for s in seqs if str(s.seq).startswith(bcs[expt])]
        nSeqs += len(bc_filtered_data[expt])
        
    logging.info('Finished barcode demuxing. Kept %i of %i sequences.' % (nSeqs, len(seqs)))
    
    return bc_filtered_data
    
#####################
# Paired End Match Filtering
#####################

def getSeqCoords(s):
	return ':'.join(s.description.split(' ')[0].split(':')[3:])
	
def getSeqSense(s):
	return s.description.split(' ')[1].split(':')[0]
    
def getCopiedSequence(s, fREs):
    return s[fREs[0].search(str(s.seq)).end():list(fREs[1].finditer(str(s.seq)))[-1].start()]
    
def copiedFunctionGenerator(fREs):
    return lambda s: getCopiedSequence(s, fREs)
	
def filterPEMismatches(f_seqs, pe_seqs, copied_func):
    """
    Takes in lists of sequences objects:
        f_seqs - sequences from forward reads. Presumably filtered for the required adatper(s).
        pe_seqs - the paired end sequences of f_seqs. Also presumably filtered for the required adapter(s).
        copied_func - takes a sequence, should ouptut the DNA that we expect to have been copied,
                        i.e. that should be on the paired end read.
                        
    Outputs a list of forward sequences that pass two filters:
        * Have a coordinate match in the paired end reads
        * That coordinate match has the same sequence.
    
    Prunes the sequences down to what was actually copied (i.e. pre-adapter)
    """
    
    logging.info('Started Paired-End Filtering')
    
    # Some housekeeping stuff
    proc_ct = 0 # number of sequences processed
    co_ct = 0 # number of sequences with coordinate matches
    aln_ct = 0 # number of sequences that have paired end sequence matches
    
    matched_seq_list = []
    
    # Get coordinate list 
    pe_coordL = [getSeqCoords(s) for s in pe_seqs]
    
    for s in f_seqs:
        if pe_coordL.count(getSeqCoords(s)): # Filter based on paired-end presence
            co_ct += 1           

            copied = copied_func(s) # Get the part of the sequence that was actually copied

            rc_idx = pe_coordL.index(getSeqCoords(s))
            rc = pe_seqs[rc_idx].reverse_complement()

            if str(pe_seqs[0].reverse_complement().seq).find(str(copied.seq)): # Filter on PE match
                aln_ct += 1

                matched_seq_list.append(copied)             
        
        proc_ct += 1
        if not (proc_ct % 5000):
            logging.info("Processed %i out of %i" % (proc_ct, len(f_seqs)))
    
    logging.info("Finished Paired-End Filtering")
    logging.info("Kept %i of %i forward sequences after coordinate filtering" % (co_ct, len(f_seqs)))
    logging.info("Kept %i of %i forward sequences after paired-end sequence matching" % (aln_ct, co_ct))
        
    return matched_seq_list
    
#####################
# Q-score Filtering
#####################

def qualityFilter(seqs, q_cutoff=20):
    logging.info('Started Quality Score Filtering')
    
    l = [s for s in seqs
            if not any(s.letter_annotations['phred_quality'] < np.ones(len(s.letter_annotations['phred_quality']))*q_cutoff)]
            
    logging.info('Finished Quality Score Filtering. Kept %i of %i sequences.' % (len(l), len(seqs)))
    return l

#####################
# Length Filtering
#####################

def seqLenFilter(seqs, l_cutoff=70, u_cutoff=200, l_barcode=0):
    logging.info('Started Length Filtering')
    
    l = [s for s in seqs if (len(s.seq) >= (l_cutoff + l_barcode)) and (len(s.seq) <= (u_cutoff + l_barcode)) ]
    
    logging.info('Finished Length Filtering. Kept %i of %i sequences.' % (len(l), len(seqs)))
    return l

#####################
# Alignment Filtering
#####################

def alignmentFilter(seqs, template, gapopen=10, gapextend=0.5, lo_cutoff=300, hi_cutoff=1000,
                    cleanup=True):
    logging.info('Started alignment-based filtering')
    start_nSeqs = len(seqs)
    
    # Save the template and sequences as temporary fasta files
    # Probably some hacking that can be done in the NeedleCommandline stuff
    # But for now, this is easiest.
    
    template_fname = 'temptemplate.fa'
    seqs_fname = 'tempseq.fa'
    
    with open(seqs_fname, 'w') as sh:
        SeqIO.write(seqs, sh, 'fastq')
    
    with open(template_fname, 'w') as tem:
        tempSeq = SeqRecord(Seq(template), id='template', name='template')
        SeqIO.write(tempSeq, tem, 'fasta')
        
    # Generate alignment command, run the alignment
    logging.info('Began EMBOSS needle routine with settings:\ngapopen: %i\ngapextend: %i\nlo_cutoff: %i\nhi_cutoff: %i' % (gapopen, gapextend, lo_cutoff, hi_cutoff))
    ofilen = 'temp_'+str(uuid.uuid4())+'.needle'
    needle_cline = NeedleCommandline(asequence=template_fname, bsequence=seqs_fname, gapopen=gapopen,
        gapextend=gapextend, outfile=ofilen)
    needle_cline()
    logging.info('Finished EMBOSS needle routine')
    
    # Read in alignment file
    # **NOTE: This code assumes you've edited EmbossIO to keep track of the score
    # and keep it as an annotation of the MultipleSeqAlign object
    
    alnData = AlignIO.parse(open(ofilen), "emboss")
    newSeqs = cull_alignments(alnData, lo_cutoff=lo_cutoff, hi_cutoff=hi_cutoff)
        
    # Exit routine
    if cleanup:
        logging.info('Cleaning up temp files')
        os.remove(template_fname)
        os.remove(seqs_fname)
        os.remove(ofilen)
    logging.info('Finished alignment-based filtering. Kept %i of %i sequences.' % (len(newSeqs), start_nSeqs))
    return newSeqs


def cull_alignments(alnData, lo_cutoff=400, hi_cutoff=650):
    newSeqs = []

    for alignment in alnData:
        if (alignment.annotations['score'] > lo_cutoff) and (alignment.annotations['score'] < hi_cutoff): # Score cutoff
            if not (str(alignment[0].seq).count('-') > 0): # Template should have no gaps, and should contain the whole non-template sequence
                newSeqs.append(alignment[1])
                newSeqs[-1].annotations['alnscore'] = alignment.annotations['score']
                # Shouldn't need indexing annotation...
    
    return newSeqs